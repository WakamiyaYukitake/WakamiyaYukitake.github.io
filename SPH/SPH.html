<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子法とSPH法</title>
    <link rel="stylesheet" href="../style.css">
    
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* 数式ブロックのマージン */
        .formula-block {
            margin: 24px 0;
            /* <center>タグを削除したため、
               text-align: center; は不要になりました。
               MathJaxが displayMath ($$) を自動で中央揃えにします。
            */
        }
        /* MathJaxが生成する数式コンテナがはみ出た場合にスクロールさせる */
        mjx-container[jax="SVG"][display="true"] {
            overflow-x: auto;
            overflow-y: hidden;
        }
        p {
            margin-bottom: 16px;
        }
        h3 {
            border-bottom: 2px solid var(--blue);
            padding-bottom: 8px;
            margin-top: 32px;
            margin-bottom: 16px;
        }
        code {
            background: rgba(255,255,255,0.05);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        
        /* ▼ 修正: strongの代わりに色と太さで強調 ▼ */
        .highlight {
            color: var(--blue);
            font-weight: 600; 
        }

        /* 参考文献リンクのスタイル */
        #sph-method ul {
            list-style-type: disc;
            padding-left: 20px;
            margin-bottom: 16px;
        }
        #sph-method ul li a {
            color: var(--blue);
            text-decoration: none;
            transition: color 200ms;
        }
        #sph-method ul li a:hover {
            color: #fff;
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <header class="site-header">
        <div class="container header-inner">
            <div class="logo">WY</div>
            <nav class="site-nav" id="site-nav">
                <a href="#particle-method">粒子法とは</a>
                <a href="#sph-method">SPH法</a>
            </nav>
            <button class="menu-btn" id="menu-btn" aria-label="Toggle navigation" aria-controls="site-nav" aria-expanded="false">☰</button>
        </div>
    </header>

    <section class="section--full hero-inner">
        <h1 class="hero-title">粒子法：SPH法</h1>
        <p class="hero-lead">
            粒子法の代表的な手法であるSPH法（Smoothed Particle Hydrodynamics）の基本原理について
        </p>
    </section>

    <div class="container">

        <section id="particle-method" class="section">
            <h2>粒子法とは</h2>
            <p>
                粒子法は、連続体の数値解析法の一つであり、解析対象である流体などを、任意の大きさを持つ<span class="highlight">粒子の集合体</span>として表現する手法である。
            </p>

            <h3>格子法との比較</h3>
            <p>
                従来広く用いられてきた格子法（有限体積法や有限要素法など）は、空間内に固定された格子点を計算点とする。 これは「オイラー的視点」に基づく。 対して、粒子法は空間内を<span class="highlight">移動する粒子そのもの</span>を計算点とする。 これは「ラグランジュ的視点」に基づいている。
            </p>
            <ul>
                <li>
                    <span class="highlight">前処理（モデル生成）:</span> 3次元の複雑な地形を扱う場合、格子法では格子生成（メッシュ作成）に多くの時間が費やされる。 粒子法では粒子を配置する「粒子生成」のみであるため、格子生成より容易である。
                </li>
                <li>
                    <span class="highlight">移流項の扱い:</span> 格子法（オイラー的視点）では、支配方程式（ナビエ・ストークス方程式）の移流項を離散化する際に、数値拡散や数値振動といった問題が生じ、高精度な計算が困難になる場合がある。
                </li>
                <li>
                    <span class="highlight">粒子法の利点:</span> 粒子法（ラグランジュ的視点）では、粒子が移動することで流れを表現するため、移流項を陽に解く必要がない。 これにより、移流項の離散化に伴う数値拡散や数値振動の問題が原理的に生じない。
                </li>
            </ul>

            <h3>粒子法の課題</h3>
            <p>
                一方で、粒子法は計算点が移動するため、圧力分布に非物理的な擾乱が生じやすいという課題がある。 この擾乱を減衰させるために、流体を「弱圧縮性」として扱うことが多いが、この手法は非物理的なエネルギーの減衰や体積の減少をもたらす可能性も指摘されている。
            </p>
        </section>

        <hr style="border-color: rgba(255,255,255,0.05); margin: 40px 0;">

        <section id="sph-method" class="section">
            <h2>SPH法</h2>
            <p>
                SPH法 (Smoothed Particle Hydrodynamics)は粒子法の一つであり、各粒子が<span class="highlight">影響範囲</span>を持つと考える。 ある粒子の物理量は、その影響範囲内に存在する近傍の粒子から影響を受けて決定される。 この影響の度合いを定義するのが「カーネル関数」である。
            </p>

            <h3>カーネル関数による物理量の近似</h3>
            <p>
                ある位置ベクトル $r$ における物理量 $f(r)$ は、カーネル関数 $W$ を用いて、影響範囲内の積分として以下のように定義される。
            </p>
            <div class="formula-block">
                $$ f(r) = \int f(r') W(|r-r'|, h) dr' \tag{式1} $$
                
            </div>
            <p>
                また、式(1)は各粒子を表す添え字a,bを用いて、式(2)のように離散化できる。
            </p>
            <div class="formula-block">
                $$ f(r_{a})=\sum_{b}f(r_{b})W(|r_{a}-r_{b}|,h)\Delta V_{b} \tag{式2} $$
                
            </div>
            <p>
                ここで $h$ は粒子の影響範囲を定義する「平滑化長さ」である。
                粒子 $b$ の体積を $\Delta V_b$、質量を $m_b$、密度を $\rho_b$ とすると、 $\Delta V_b = m_b / \rho_b$ の関係から、粒子 $a$ の物理量 $f(r_a)$ は以下の和として近似できる。
            </p>
            <div class="formula-block">
                $$ f(r_a) = \sum_b f(r_b) \frac{m_b}{\rho_b} W(|r_a - r_b|, h) \tag{式3} $$
                
            </div>
            <p>
                カーネル関数 $W$ にはいくつかの種類があるが、ここでは Wendland kernel を用いる。 $q$ は粒子間の無次元距離 ($q=r/h$) である。
            </p>
            <div class="formula-block">
                $$ W(r,h)=\alpha_{D} \begin{cases} (1-\frac{q}{2})^{4}(2q+1) & 0 \le q \le 2 \\ 0 & q > 2 \end{cases} \tag{式4} $$
                
            </div>

            <h3>支配方程式の離散化</h3>
            <p>
                SPH法では、流体の運動を記述する「ナビエ・ストークス方程式」と「連続式」を、前述の<span class="highlight">カーネル関数</span>を用いて離散化する。
                流体は弱圧縮性流体とする。 粒子の体積を $\Delta V[m^{3}]$ とすると、粒子にかかる圧力が $-V \nabla p$ ,粘性力が $\mu\nabla^{2}u$ であることから、式(5)が求められる。
            </p>
            <div class="formula-block">
                $$ m\frac{du}{dt}=-V\nabla p+V\mu\nabla^{2}u+mg \tag{式5} $$
                
            </div>
            <p>
                ここで、uは粒子の速度[m/s], pは圧力[Pa], $\mu$は粘性係数[Pas], gは重力加速度[m/s²]である。 また、粒子の密度を $\rho[kg/m^{3}]$ とすると、 $m=\rho V$ であることから、式(6)が得られる。
            </p>
            <div class="formula-block">
                $$ \rho\frac{du}{dt}=-\nabla p+\mu\nabla^{2}u+\rho g \tag{式6} $$
                
            </div>
            <p>
                vを動粘性係数[$m^{2}/s$]とすると粘性項の係数は $\mu/\rho = v$ から、式(7)が得られる。
            </p>
            <div class="formula-block">
                $$ \frac{du}{dt} = - \frac{1}{\rho} \nabla p + \nu \nabla^2 u + g \tag{式7} $$
                
            </div>
            <p>
                この式(7)をSPH法に基づき離散化すると、粒子 $a$ の速度変化（加速度） $\frac{du_a}{dt}$ は、近傍の粒子 $b$ との相互作用として以下の（式8）で表される。
            </p>
            <div class="formula-block">
                $$ \frac{du_a}{dt} = - \sum_b m_a \left( \frac{p_b}{\rho_b^2} + \frac{p_a}{\rho_a^2} + \Pi_{ab} \right) \nabla W(|r_a - r_b|, h) + g \tag{式8} $$
                
            </div>
            <p>
                ここで、$\Pi_{ab}$ は数値的な安定性を確保するために導入される「人工粘性項」であり、粒子同士が近づきすぎた場合に反発力として機能する。
            </p>
            <div class="formula-block">
                $$ \Pi_{ab} = \begin{cases} \frac{-\alpha \bar{c}_{ab} \mu_{ab}}{\bar{\rho}_{ab}} & v_{ab} \cdot r_{ab} < 0 \\ 0 & v_{ab} \cdot r_{ab} > 0 \end{cases} \tag{式9} $$
                
            </div>

            <h4>連続式（質量保存則）</h4>
            <p>
                流体の密度 $\rho$ の時間変化は、連続式によって記述される。 粒子 $a$ の密度変化 $\frac{d\rho_a}{dt}$ は、近傍粒子 $b$ との速度差 $u_a - u_b$ を用いて、以下の（式10）で表される。
            </p>
            <div class="formula-block">
                $$ \frac{d\rho_a}{dt} = - \rho_a \sum_b \frac{m_b}{\rho_b} (u_a - u_b) \cdot \nabla W(|r_a - r_b|, h) \tag{式10} $$
                
            </div>
            
            <h4>状態方程式</h4>
            <p>
                SPH法では流体を「弱圧縮性」として扱うため、密度 $\rho$ と圧力 $p$ を関係づける「状態方程式」が必要となる。 以下の（式11）が用いられる。
            </p>
            <div class="formula-block">
                $$ p = \frac{c_0^2 \rho_0}{\gamma} \left( \left( \frac{\rho}{\rho_0} \right)^\gamma - 1 \right) \quad (\gamma = 7) \tag{式11} $$
                
            </div>
            <p>
                ここで $c_0$ は基準となる音速、 $\rho_0$ は基準密度である。 圧力 $p$ は密度の変化（圧縮）によって生じる力として計算される。
            </p>
            
            <h3>物理量の計算</h3>
            <p>
                シミュレーションの結果として、特定の点における流速 $v_a$ や圧力 $p_a$ は、その点に隣接する流体粒子 $b$ の速度 $v_b$ や圧力 $p_b$ をカーネル関数で重み付け平均することで求められる。
            </p>
            <div class="formula-block">
                $$ v_a = \frac{\sum_b v_b W(|r_a - r_b|, h)}{\sum_b W(|r_a - r_b|, h)} \tag{式12} $$
                
            </div>
            <div class="formula-block">
                $$ p_a = \frac{\sum_b p_b W(|r_a - r_b|, h)}{\sum_b W(|r_a - r_b|, h)} \tag{式13} $$
                
            </div>

            <h3 style="margin-top: 40px;">参考文献</h3>
            <p>
                その他、DualSPHysicsにおける計算式は以下ページを参考。
            </p>
            <ul>
                <li><a href="https://github.com/DualSPHysics/DualSPHysics/wiki/3.-SPH-formulation" target="_blank" rel="noopener noreferrer">DualSPHysics Wiki - 3. SPH formulation</a></li>
            </ul>

        </section>

    </div><footer class="site-footer">
        <p class="small-muted">© 2025 Fluid Dynamics Analysis. All rights reserved.</p>
    </footer>

    <script>
        // Mobile menu toggle
        const menuBtn = document.getElementById('menu-btn');
        const siteNav = document.getElementById('site-nav');
        if (menuBtn && siteNav) {
            menuBtn.addEventListener('click', () => {
                const isOpen = siteNav.classList.toggle('open');
                menuBtn.setAttribute('aria-expanded', isOpen);
            });
        }

        // Scroll-in-view animation
        const sections = document.querySelectorAll('.section');
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('in-view');
                }
            });
        }, {
            threshold: 0.1
        });

        sections.forEach(section => {
            observer.observe(section);
        });
    </script>
</body>
</html>